//魔法盒子
//时间限制： 3000MS
//内存限制： 589824KB
//题目描述：
//对于一个序列A，我们定义序列(A+1)为将序列A里每个元素值都加1得到的序列。
//
//例如：[3, 4, 2]+1=[4, 5, 3]，[1, 2, 1]+1=[2, 3, 2]。
//
//对于序列A和B，我们定义序列C=A*B表示序列C是由序列A和序列B拼接而成（序列A在前，序列B在后）。
//
//例如：[2, 3, 1]*[1, 2, 1]=[2, 3, 1, 1, 2, 1]；
//
//[1, 2, 3]*[2, 3]*[5, 4]=[1, 2, 3, 2, 3]*[5, 4]=[1, 2, 3, 2, 3, 5, 4]。
//
//小团得到了一个魔法盒子。
//
//将序列A放入魔法盒子内，将会弹出序列(A+1)*A*(A+2)。
//
//小团先将仅由一个数0构成的序列[0]放入魔法盒子，然后不断将魔法盒子弹出的序列再次放入。现在小团想问，他这样操作第n次时魔法盒子弹出序列中第k个位置的值是多少？
//
//
//
//例如：一开始的序列为[0]，第1次放入后弹出的结果是[1, 0, 2]，第2次是[2, 1, 3, 1, 0, 2, 3, 2, 4]，第3次是[3, 2, 4, 2, 1, 3, 4, 3, 5, 2, 1, 3, 1, 0, 2, 3, 2, 4, 4, 3, 5, 3, 2, 4, 5, 4, 6]。
//
//
//
//输入描述
//一行两个空格隔开的整数n，k，表示初始序列为[0]，小团想知道第n次弹出的序列的第k个数是多少。
//
//数据保证 ：1<=n<=35, 1<=k<=3^n
//
//输出描述
//一个整数，表示第n次弹出的序列的第k个数。
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
using llong=long long;

int cal(int n,int k){
	llong res=0;
	while(n--){
		llong chunkSize=pow(3,n);
		if(k>2*chunkSize){
			// 在右边，+2
			res += 2;
			k-=2*chunkSize;
		}else if(k>chunkSize){
			// 在中间，0
			k-=chunkSize;
		}else{
			// 在左边,+1
			res += 1;
		}
	}
	return res;
}
int main(int argc, char *argv[]) {
	llong n,k;
	cin>>n>>k;
	cout<<cal(n,k)<<endl;
	return 0;
}